{"version":3,"sources":["animate-scroll-to.js"],"names":["root","factory","module","exports","define","amd","animateScrollTo","this","DEFAULTS","duration","animate","shorthand","top","bottom","scrollBottom","elem","window","document","documentElement","scrollHeight","innerHeight","clientHeight","scrollTo","x","y","scroll","scrollLeft","scrollTop","target","options","callback","arguments","length","distance","container","speed","val","isDefined","paused","startTop","getStartTop","endTop","match","sign","+","-","step","parseFloat","getEndTop","isNaN","Math","min","max","console","log","start","pause","resume","isPaused","_startTop","_duration","_distance","setTimeout","ctx","now","Date","elapsed","startTime","ratio","isEnd","requestAnimationFrame","pageYOffset","body","ceil","defaults"],"mappings":"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","file":"animate-scroll-to.min.js","sourcesContent":["!function(root, factory) {\r\n  if (typeof module != 'undefined') module.exports = factory();\r\n  else if (typeof define == 'function' && typeof define.amd == 'object') define(factory);\r\n  else root.animateScrollTo = factory();\r\n}(this, function() {\r\n\r\n  // CONSTANT\r\n  // ==\r\n  var DEFAULTS = {\r\n    duration: 468,\r\n    animate: true\r\n  };\r\n  \r\n  var shorthand = {\r\n    top: function() { return 0 },\r\n    bottom: scrollBottom\r\n  };\r\n\r\n  // Utils\r\n  // ==\r\n  function isDefined(val) {\r\n    return val !== void 0;\r\n  }\r\n\r\n  function scrollTop(elem) {\r\n    if (elem === window) {\r\n      var top = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;\r\n      // handle top is float or not\r\n      return top%1 != 0 ? Math.ceil(top - 1) : top;\r\n    } else {\r\n      return elem.scrollTop;\r\n    }\r\n  }\r\n\r\n  function scrollBottom(elem) {\r\n    if (elem === window) {\r\n      return document.documentElement.scrollHeight - window.innerHeight;\r\n    } else {\r\n      return elem.scrollHeight - elem.clientHeight;\r\n    }\r\n  }\r\n\r\n  function scrollTo(elem, x, y) {\r\n    if (elem === window) {\r\n      window.scroll(x, y);\r\n    } else {\r\n      elem.scrollLeft = x;\r\n      elem.scrollTop = y;\r\n    }\r\n  }\r\n\r\n  // Public\r\n  // ==\r\n  function scroll(target, options, callback) {\r\n    if (arguments.length == 2 && typeof options === 'function') {\r\n      callback = options;\r\n    }\r\n\r\n    options = options || {}\r\n\r\n    var container = options.container || window,\r\n        duration = options.duration || DEFAULTS.duration,\r\n        speed = options.speed,\r\n        animate = isDefined(options.animate) ? options.animate : DEFAULTS.animate;\r\n\r\n    var paused = true,\r\n        startTop = getStartTop(container),\r\n        endTop = getEndTop(target, startTop, container),\r\n        direction,\r\n        distance;\r\n\r\n    if (isNaN(endTop)) return;\r\n    \r\n    direction = endTop - startTop;\r\n\r\n    endTop = direction > 0 ?\r\n      Math.min(scrollBottom(container), endTop):\r\n      Math.max(0, endTop);\r\n\r\n    distance = endTop - startTop;\r\n\r\n    console.log(scrollBottom(container));\r\n\r\n    start();\r\n\r\n    // scroller instance\r\n    return {\r\n      start: start,\r\n\r\n      pause: function() {\r\n        paused = true;\r\n      },\r\n\r\n      resume: function() {\r\n        if (paused) start(getStartTop(container));\r\n      },\r\n\r\n      isPaused: function() {\r\n        return paused;\r\n      }\r\n    }\r\n\r\n    function start(_startTop) {\r\n      // re-calucate distance and duration when resume\r\n      var _startTop = _startTop || startTop,\r\n          _distance = endTop - _startTop,\r\n          _duration;\r\n \r\n      // check distance is none or over\r\n      if (_distance === 0 || (_distance / distance) < 0) {\r\n        return setTimeout(callback);\r\n      };\r\n\r\n      _duration = (_distance / distance) * duration;\r\n      paused = false;\r\n\r\n      step({\r\n        container: container,\r\n        startTime: +new Date,\r\n        startTop: _startTop,\r\n        endTop: endTop,\r\n        distance: _distance,\r\n        duration: _duration,\r\n        animate: animate,\r\n        speed: speed,\r\n        callback: callback\r\n      });\r\n    }\r\n\r\n    function step(ctx) {\r\n      if (paused) return;\r\n\r\n      var now = +new Date,\r\n          scrollTop,\r\n          elapsed = now - ctx.startTime;\r\n\r\n      // calculate the position.\r\n      if (ctx.speed) {\r\n        scrollTop = ctx.startTop + elapsed / 1000 * ctx.speed;\r\n      } else {\r\n        var ratio = elapsed / ctx.duration;\r\n        scrollTop = ctx.startTop + (ctx.distance * ratio);\r\n      }\r\n\r\n      var isEnd = ctx.distance > 0 ? \r\n        scrollTop >= ctx.endTop :\r\n        scrollTop <= ctx.endTop;\r\n  \r\n      if (isEnd || !ctx.animate) {\r\n        paused = true; // when scroll to end, pause it\r\n        scrollTo(ctx.container, 0, ctx.endTop)\r\n        setTimeout(ctx.callback);\r\n      } else {\r\n        scrollTo(ctx.container, 0, scrollTop)\r\n        requestAnimationFrame(function() { step(ctx) });\r\n      }\r\n    }\r\n  }\r\n\r\n  // Private\r\n  // ==\r\n  function getStartTop(elem) {\r\n    return scrollTop(elem);\r\n  }\r\n\r\n  function getEndTop(target, startTop, container) {\r\n    switch (typeof target) {\r\n      case 'number':\r\n        return target;\r\n      case 'string':\r\n        var match = target.match(/^(?:([+-])=)(\\d+(?:\\.\\d+)?)$/);\r\n        if (match) {\r\n          var sign = {'+': 1, '-': -1}[match[1]],\r\n              step = match[2] * sign;\r\n          return startTop + step;\r\n        } else if (shorthand[target]) {\r\n          return shorthand[target](container);\r\n        } else {\r\n          return parseFloat(target);\r\n        }\r\n    }\r\n  }\r\n\r\n  // Exports\r\n  // ==\r\n  scroll.defaults = DEFAULTS;\r\n  return scroll;\r\n});"]}